# =================================================
# OpenWrt IPK 多仓库构建工作流
# 仓库: https://github.com/somemoo/OpenWrt
# 特性: 支持多仓库回退/架构选择/增量编译
# 许可证: MIT  
# 作者: vison.v
# =================================================

name: OpenWrt-IPK-Builder

on: 
  workflow_dispatch:
    inputs:
      Model:
        description: '选择设备（与架构互斥）'
        required: false
        default: ''
        type: choice
        options: ['普通PC', '迷你主机', 'Proxmox VE虚拟机', 'VMware虚拟机', '小米路由器4A千兆版', 'Xiaomi R4A', 'Redmi AX6', 'Redmi AX6000', '小米AX3600', 'Xiaomi AX9000', 'ASUS RT-ACRH17', 'ASUS RT-AC58U', 'ASUS RT-AX86U', 'ASUS RT-AX88U', 'Netgear R7800', 'Netgear XR500', 'Netgear WAX202', 'Linksys WRT1900ACS', 'Linksys WRT3200ACM', 'Linksys EA7500v2', 'GL.iNet MT1300', 'GL.iNet AX1800', '斐讯K3', 'Newifi D2', '极路由4 HC5962', 'Raspberry Pi 4B']
      Arch:
        description: '选择架构（与设备互斥）'
        required: false
        default: 'x86/64'
        type: choice
        options: ['x86/64', 'ramips/mt7621', 'ipq807x/generic', 'ipq40xx/generic', 'ipq806x/generic', 'bcm4908/generic', 'bcm27xx/bcm2711', 'mediatek/mt7622', 'mediatek/mt7986', 'rockchip/armv8', 'mvebu/cortexa9', 'ath79/generic', 'lantiq/xrx200', 'realtek/rtl838x', 'realtek/rtl930x', 'zynq/generic']
      Package:
        description: '输入包名 (例如: luci-app-adguardhome)'
        required: false
        type: string

env:
  TZ: Asia/Shanghai

jobs:
  matrix:
    runs-on: ubuntu-latest
    if: github.event.repository.owner.id == github.event.sender.id || !github.event.sender.id
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      repo_url: ${{ steps.set-matrix.outputs.repo_url }}
      target_arch: ${{ steps.set-arch.outputs.arch }}
    
    steps:
      - name: 检出代码
        uses: actions/checkout@main
        with:
          fetch-depth: 0

      - name: 配置文件校验
        run: |
          # 校验Archs文件格式
          if grep -qE '[^/]/[^/ ]+' scripts/Archs; then
              echo "::error::Archs文件包含非法架构格式（必须为target/subtarget）"
              exit 1
          fi
          
          # 校验Models文件格式
          if ! grep -qE '^[^:]+:[^:]+' scripts/Models; then
              echo "::error::Models文件存在格式错误行（必须为 设备列表:架构）"
              exit 1
          fi

      - name: 输入验证
        run: |
          if [[ -n "${{ github.event.inputs.Model }}" && -n "${{ github.event.inputs.Arch }}" ]]; then
            echo "::error::不能同时选择设备和架构"
            exit 1
          elif [[ -z "${{ github.event.inputs.Model }}" && -z "${{ github.event.inputs.Arch }}" ]]; then
            echo "::error::必须选择设备或架构"
            exit 1
          fi

      - name: 设置目标架构
        id: set-arch
        run: |
          # 从配置文件读取设备-架构映射
          declare -A MODEL_ARCH_MAP
          while IFS=: read -r models arch; do
            # 跳过注释行和空行
            [[ "$models" =~ ^# ]] && continue
            [[ -z "$models" ]] && continue
            
            # 清理空格并分割设备列表
            clean_models=$(echo "$models" | xargs)
            IFS=',; ' read -ra model_arr <<< "$clean_models"
            
            # 保存到关联数组
            for model in "${model_arr[@]}"; do
              MODEL_ARCH_MAP["$(echo $model | xargs)"]=$(echo "$arch" | xargs)
            done
          done < scripts/Models

          if [[ -n "${{ github.event.inputs.Model }}" ]]; then
            selected_model="${{ github.event.inputs.Model }}"
            if [[ ! -v MODEL_ARCH_MAP["$selected_model"] ]]; then
              echo "::error::未找到 $selected_model 对应的架构"
              exit 1
            fi
            resolved_arch=${MODEL_ARCH_MAP["$selected_model"]}
            echo "选择的设备: $selected_model → $resolved_arch"
            echo "arch=$resolved_arch" >> $GITHUB_OUTPUT
          else
            validate_arch="${{ github.event.inputs.Arch }}"
            # 使用正则匹配架构是否存在
            if ! grep -qE "(^|[,; ])$validate_arch([,; ]|$)" scripts/Archs; then
              echo "::error::无效的架构: $validate_arch"
              exit 1
            fi
            echo "选择的架构: $validate_arch"
            echo "arch=$validate_arch" >> $GITHUB_OUTPUT
          fi

      - name: 构建矩阵
        id: set-matrix
        run: |
          PACKAGE_INPUT="${{ github.event.inputs.Package }}"
          REPO_URL="https://github.com/somemoo/OpenWrt-packages"
          BRANCH="lede"
          PKG_ARRAY=()
          USE_BUILD_FILE=false

          if [ -f "Build-IPK" ]; then
            echo "检测到 Build-IPK 文件存在"
            declare -a tmp_pkgs
            while IFS= read -r line; do
              # 跳过注释和空行
              [[ "$line" =~ ^[[:space:]]*# ]] && continue
              [[ -z "${line// }" ]] && continue
              
              # 使用多种分隔符分割
              IFS=',; ' read -ra pkgs <<< "$line"
              for pkg in "${pkgs[@]}"; do
                clean_pkg=$(echo "$pkg" | xargs)
                [ -n "$clean_pkg" ] && tmp_pkgs+=("$clean_pkg")
              done
            done < Build-IPK
            
            if [ ${#tmp_pkgs[@]} -gt 0 ]; then
              echo "文件内容有效，包含 ${#tmp_pkgs[@]} 个包"
              if git diff --quiet HEAD^ HEAD -- "Build-IPK" 2>/dev/null; then
                echo "文件未修改，回退到输入/默认包"
              else
                PKG_ARRAY=("${tmp_pkgs[@]}")
                USE_BUILD_FILE=true
              fi
            fi
          fi

          git clone -b $BRANCH --single-branch $REPO_URL OpenWrt-packages
          cd OpenWrt-packages

          if [ "$USE_BUILD_FILE" = false ]; then
            if [ -n "$PACKAGE_INPUT" ]; then
              echo "使用用户输入包：$PACKAGE_INPUT"
              IFS=',; ' read -ra PKG_ARRAY <<< "$PACKAGE_INPUT"
            else
              echo "使用默认包搜索策略"
              PKG_ARRAY=($(find . -maxdepth 1 -type d -name 'luci-app-*' -printf '%f\n'))
              if [ ${#PKG_ARRAY[@]} -eq 0 ]; then
                echo "::warning::主仓库未找到默认包，尝试备用仓库..."
                cd ..
                rm -rf OpenWrt-packages
                REPO_URL="https://github.com/kiddin9/kwrt-packages"
                BRANCH="main"
                git clone -b $BRANCH --single-branch $REPO_URL OpenWrt-packages
                cd OpenWrt-packages
                PKG_ARRAY=($(find . -maxdepth 1 -type d -name 'luci-app-*' -printf '%f\n'))
              fi
            fi
          fi

          # 包存在性验证（新增备用仓库检查逻辑）
          if [ ${#PKG_ARRAY[@]} -gt 0 ]; then
            check_pkg_existence() {
              local repo_url=$1
              local branch=$2
              local pkg_array=("${@:3}")
              
              git clone -b $branch --single-branch $repo_url temp-repo
              cd temp-repo
              for pkg in "${pkg_array[@]}"; do
                if [ ! -d "$pkg" ]; then
                  cd ..
                  rm -rf temp-repo
                  return 1
                fi
              done
              cd ..
              rm -rf temp-repo
              return 0
            }

            if ! check_pkg_existence $REPO_URL $BRANCH "${PKG_ARRAY[@]}"; then
              echo "::warning::包在主仓库不存在，尝试备用仓库..."
              REPO_URL="https://github.com/kiddin9/kwrt-packages"
              BRANCH="main"
              if ! check_pkg_existence $REPO_URL $BRANCH "${PKG_ARRAY[@]}"; then
                echo "::error::以下包在仓库中不存在: ${PKG_ARRAY[@]}"
                exit 1
              fi
            fi
          else
            echo "::error::未找到任何有效包"
            exit 1
          fi

          targets_json=$(jq -c -n --argjson arr "$(printf '%s\n' "${PKG_ARRAY[@]}" | jq -R . | jq -s .)" '$arr')
          
          cd ..
          rm -rf OpenWrt-packages
          echo "matrix=$targets_json" >> $GITHUB_OUTPUT
          echo "repo_url=$REPO_URL" >> $GITHUB_OUTPUT

  build:
    name: 构建 ${{ matrix.target }}-(${{ matrix.arch }})
    runs-on: ubuntu-latest
    needs: matrix
    strategy:
      matrix:
        target: ${{ fromJson(needs.matrix.outputs.matrix) }}
        arch: ["${{ github.event.inputs.Arch }}"]
      fail-fast: false
    
    env:
      REPO_URL: ${{ needs.matrix.outputs.repo_url }}

    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 加载环境
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          sudo apt-get update -qq
          sudo apt-get install -qq --no-install-recommends \
            aria2 build-essential clang llvm flex g++ gawk gcc-multilib gettext \
            git libncurses5-dev libssl-dev python3 python3-pyelftools python3-setuptools \
            rsync unzip zstd zlib1g-dev jq subversion qemu-utils ccache \
            libelf-dev device-tree-compiler libgmp3-dev libmpc-dev  
          sudo apt-get autoremove --purge -qq
          sudo rm -rf /var/lib/apt/lists/*
          sudo timedatectl set-timezone "Asia/Shanghai"
          git clone --depth=1 https://github.com/openwrt-dev/po2lmo
          (cd po2lmo && sudo make && sudo make install)

      - name: 设置变量
        id: ENV
        run: |
          echo "date=$(date +'%m.%d')" >> $GITHUB_ENV
          echo "arch_path=$(echo ${{ matrix.arch }} | tr '/' '-')" >> $GITHUB_ENV

      - name: 准备SDK
        run: |
          SDK_URL1="https://downloads.immortalwrt.org/releases/24.10-SNAPSHOT/targets/${{ matrix.arch }}/immortalwrt-sdk-24.10-SNAPSHOT-${{ env.arch_path }}_gcc-13.3.0_musl.Linux-x86_64.tar.zst"
          SDK_URL2="https://downloads.immortalwrt.org/releases/24.10-SNAPSHOT/targets/${{ matrix.arch }}/immortalwrt-sdk-24.10-SNAPSHOT-${{ env.arch_path }}_gcc-13.3.0_musl_eabi.Linux-x86_64.tar.zst"
          wget --spider -q "$SDK_URL1" && wget "$SDK_URL1" || wget "$SDK_URL2"
          mkdir OpenWrt-${{ env.arch_path }} && tar -I 'zstd -d' -xf immortalwrt-*.tar.zst -C OpenWrt-${{ env.arch_path }} --strip-components 1 && rm immortalwrt-*.tar.zst

      - name: 克隆项目
        run: |
          shopt -s extglob
          cp -rf App/. OpenWrt-${{ env.arch_path }}/
          cd OpenWrt-${{ env.arch_path }}
          ./scripts/feeds update -a
          rm -Rf feeds/luci/{applications,collections,protocols,themes,libs,docs,contrib}
          rm -Rf feeds/luci/modules/!(luci-base)
          rm -Rf feeds/packages/!(lang|libs|devel|utils|net|multimedia)
          rm -Rf feeds/packages/multimedia/!(gstreamer1|ffmpeg)
          rm -Rf feeds/packages/net/!(mosquitto|curl)
          rm -Rf feeds/base/package/firmware
          rm -Rf feeds/base/package/network/!(services|utils)
          rm -Rf feeds/base/package/network/services/!(ppp)
          rm -Rf feeds/base/package/system/!(opkg|ubus|uci|ca-certificates)
          rm -Rf feeds/base/package/kernel/!(cryptodev-linux)
          sed -i '/	refresh_config();/d' scripts/feeds
          
          # 根据仓库类型处理路径
          if [[ "$REPO_URL" == *"kiddin9"* ]]; then
            git clone -b main $REPO_URL packages
            mv packages/* package/
            rm -rf {packages,.github,.gitignore,LICENSE,README.md}
          else
            git clone -b lede $REPO_URL packages 
            mv packages/* package/
            rm -rf {packages,package/golang}
          fi
          
          ./scripts/feeds update -a
          ./scripts/feeds install ${{ matrix.target }}
          
          if [ -f "package/${{ matrix.target }}/Makefile" ]; then
            echo "CONFIG_PACKAGE_${{ matrix.target }}=y" >> .config
          else
            echo "::error::包 ${{ matrix.target }} 最终不存在于仓库中"
            exit 1
          fi

      - name: 下载依赖
        id: package
        run: |
          cd OpenWrt-${{ env.arch_path }}
          mv -f feeds/base feeds/base.bak
          mv -f feeds/packages feeds/packages.bak
          make defconfig
          mv -f feeds/packages.bak feeds/packages
          mv -f feeds/base.bak feeds/base

      - name: 开始编译
        run: |
          cd OpenWrt-${{ env.arch_path }}
          make package/${{ matrix.target }}/compile -j$(nproc) V=s

      - name: 准备 ipk
        run: |
          cd OpenWrt-${{ env.arch_path }}
          mkdir -p ./artifact/IPK
          find ./bin/packages/*/*/ -maxdepth 1 -type f -name "*.ipk" | xargs -i mv -f {} ./artifact/IPK/
          cd ./artifact/IPK
          echo "IPK=$PWD" >> $GITHUB_ENV

      - name: 上传 ipk
        uses: actions/upload-artifact@v4
        id: upipk
        with:
          name: ${{ env.date }} (${{ env.arch_path }})-${{ matrix.target }}
          path: ${{ env.IPK }}
